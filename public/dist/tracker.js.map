{"version":3,"file":"tracker.js","mappings":";;;;;;;;;;;;;;;;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,kCAAkC;;AAE9C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,UAAU,mBAAmB,YAAY,WAAW;AAClG,iCAAiC;AACjC;AACA;;AAEA;AACA;;AAEA;;;;;;;;UCtCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNqF;;AAErF;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC,oBAAoB,4BAA4B;AAChD;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,wBAAwB,SAAS,EAAE,OAAO;AAC1C;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,mBAAmB,aAAa,GAAG,cAAc;AACjD;AACA,iBAAiB,gEAAc;AAC/B,iBAAiB,4DAAc;AAC/B,KAAK;;AAEL;AACA,YAAY,4DAAU;;AAEtB,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;;AAEA,kDAAkD;AAClD;;AAEA;AACA;AACA,gBAAgB;;AAEhB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,qCAAqC,gCAAgC;AACrE;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS,4DAAU;AACnB,4BAA4B,sDAAI;AAChC,+BAA+B,sDAAI;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC,U","sources":["webpack://kibanalytics/./src/client/utils.client.js","webpack://kibanalytics/webpack/bootstrap","webpack://kibanalytics/webpack/runtime/define property getters","webpack://kibanalytics/webpack/runtime/hasOwnProperty shorthand","webpack://kibanalytics/webpack/runtime/make namespace object","webpack://kibanalytics/./src/client/tracker.client.js"],"sourcesContent":["const hook = (_this, method, callback) => {\n    const orig = _this[method];\n\n    return (...args) => {\n        callback.apply(null, args);\n\n        return orig.apply(_this, args);\n    };\n};\n\nconst doNotTrack = () => {\n    const { doNotTrack, navigator, external } = window;\n\n    const msTrackProtection = 'msTrackingProtectionEnabled';\n    const msTracking = () => {\n        return external && msTrackProtection in external && external[msTrackProtection]();\n    };\n\n    const dnt = doNotTrack || navigator.doNotTrack || navigator.msDoNotTrack || msTracking();\n\n    return dnt == '1' || dnt === 'yes';\n};\n\nconst adBlockEnabled = () => {\n    let ade;\n    const boe = document.getElementsByTagName('body')[0];\n\n    if (boe) {\n        ade = document.createElement('div');\n        ade.setAttribute('class', 'ads ad adsbox doubleclick ad-placement carbon-ads');\n        ade.setAttribute('style', 'height:1px;width:1px;position: absolute;left:-999px;top:-999px;');\n        ade.textContent = '&nbsp;';\n        boe.appendChild(ade);\n    }\n\n    return !!ade && ade.offsetHeight === 0;\n}\n\nconst cookiesEnabled = (navigator && navigator.cookieEnabled) || !!document.cookie;\n\nexport {\n    hook,\n    doNotTrack,\n    adBlockEnabled,\n    cookiesEnabled\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { adBlockEnabled, cookiesEnabled, doNotTrack, hook } from './utils.client.js';\n\n(window => {\n    const {\n        screen,\n        navigator: { language, platform },\n        location: { hostname, pathname, search },\n        document,\n        history,\n    } = window;\n\n    const script = document.querySelector('script');\n    if (!script) return;\n\n    const attr = script.getAttribute.bind(script);\n\n    const tracker_id = attr('data-tracker-id');\n    if (!tracker_id) throw new Error('data-tracker-id not found');\n\n    const serverUrl = attr('data-server-url');\n    if (!serverUrl) throw new Error('data-server-url not found');\n\n    const metrics = attr('data-metrics') ? JSON.parse(attr('data-metrics')) : {};\n\n    const eventClass = /^kibanalytics--([a-z]+)--([\\w]+[\\w-]*)$/;\n    const eventSelector = '[class*=\\'kibanalytics--\\']';\n    const listeners = {};\n    let currentUrl = `${pathname}${search}`;\n    let currentRef = document.referrer;\n\n    /* Collect metrics */\n\n    const getDefaultPayload = () => ({\n        tracker_id,\n        hostname,\n        url: currentUrl\n    });\n\n    const getPageViewPayload = () => ({\n        ...getDefaultPayload(),\n        referrer: currentRef,\n        platform,\n        screen: `${screen.width}x${screen.height}`,\n        language,\n        adBlock: adBlockEnabled(),\n        cookies: cookiesEnabled\n    });\n\n    const collect = (type, payload, sendBeacon = false) => {\n        if (doNotTrack()) return;\n\n        const url = `${serverUrl}/collect`;\n        const body = {\n            type,\n            metrics,\n            payload\n        }\n\n        if (sendBeacon) {\n            /*\n                A problem with sending analytics is that a site often wants to send analytics when the user\n                has finished with a page: for example, when the user navigates to another page. In this situation\n                the browser may be about to unload the page, and in that case the browser may choose not to send\n                asynchronous XMLHttpRequest requests.\n             */\n            return navigator.sendBeacon(url, JSON.stringify(body));\n        }\n\n        return fetch(url, {\n            method: 'post',\n            headers: {\n                'content-type': 'application/json'\n            },\n            body: JSON.stringify(body),\n            credentials: 'include'\n        });\n    };\n\n    const trackEvent = (type = 'custom', data = {}, element = null) => {\n        const sendBeacon = element ? element.tagName === 'A' : false;\n\n        const payload = (type === 'page-view' && !element)\n            ? getPageViewPayload()\n            : { ...getDefaultPayload(), data };\n\n        collect(type, payload, sendBeacon);\n    };\n\n    /* Handle events */\n\n    const addEvents = node => {\n        const elements = node.querySelectorAll(eventSelector);\n        Array.prototype.forEach.call(elements, addEvent);\n    };\n\n    const addEvent = element => {\n        const classes = element.getAttribute('class')?.split(' ');\n        for (const className of classes) {\n            if (!eventClass.test(className)) continue;\n\n            const [prefix, type, value] = className.split('--');\n            let listener = listeners[className];\n            if (!listener) {\n                listener = listeners[className] ? listeners[className] : () => trackEvent(type, value, element);\n                listeners[className] = listener\n            }\n\n            element.addEventListener(type, listener, true);\n        }\n    };\n\n    /* Handle history changes */\n\n    const handlePush = (state, title, url) => {\n        if (!url) return;\n\n        currentRef = currentUrl;\n        const newUrl = url.toString();\n\n        if (newUrl.substring(0, 4) === 'http') {\n            currentUrl = '/' + newUrl.split('/').splice(3).join('/');\n        } else {\n            currentUrl = newUrl;\n        }\n\n        if (currentUrl !== currentRef) {\n            trackEvent('pageView');\n        }\n    };\n\n    const observeDocument = () => {\n        const monitorMutate = mutations => {\n            mutations.forEach(mutation => {\n                const element = mutation.target;\n                addEvent(element);\n                addEvents(element);\n            });\n        };\n\n        const observer = new MutationObserver(monitorMutate);\n        observer.observe(document, { childList: true, subtree: true });\n    };\n\n    /* Global */\n\n    if (!window.kibanalytics) {\n        window.kibanalytics = {\n            trackEvent\n        };\n    }\n\n    /* Start */\n\n    if (!doNotTrack()) {\n        history.pushState = hook(history, 'pushState', handlePush);\n        history.replaceState = hook(history, 'replaceState', handlePush);\n\n        const update = () => {\n            if (document.readyState === 'complete') {\n                trackEvent('page-view');\n                addEvents(document);\n                observeDocument();\n            }\n        };\n\n        document.addEventListener('readystatechange', update, true);\n        update();\n    }\n})(window);"],"names":[],"sourceRoot":""}