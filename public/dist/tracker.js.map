{"version":3,"file":"tracker.js","mappings":";;;;;;;;;;;;;;;AAAuD;;AAEvD,iEAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,oEAAqB;;AAE5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1BA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY,kCAAkC;;AAE9C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,UAAU,mBAAmB,YAAY,WAAW;AAClG,iCAAiC;AACjC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,SAAS,IAAI;AACb;;;;;;;;UClDA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACNoD;AACwD;;AAE5G;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC,oBAAoB,4BAA4B;AAChD;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB,uEAAqB;;AAEzC;AACA;AACA;AACA,wBAAwB,SAAS,EAAE,OAAO;AAC1C;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,mBAAmB,aAAa,GAAG,cAAc;AACjD;AACA,iBAAiB,gEAAc;AAC/B,iBAAiB,4DAAc;AAC/B,KAAK;;AAEL;AACA,YAAY,4DAAU;;AAEtB,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4DAA4D,2BAA2B;AACvF;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;;AAEA,kDAAkD,cAAc;AAChE;AACA;AACA,gBAAgB;;AAEhB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2DAA2D,kEAAa;;AAExE;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,qCAAqC,gCAAgC;AACrE;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS,4DAAU;AACnB,4BAA4B,sDAAI;AAChC,+BAA+B,sDAAI;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC,U","sources":["webpack://kibanalytics/./src/client/class-listener.client.js","webpack://kibanalytics/./src/client/utils.client.js","webpack://kibanalytics/webpack/bootstrap","webpack://kibanalytics/webpack/runtime/define property getters","webpack://kibanalytics/webpack/runtime/hasOwnProperty shorthand","webpack://kibanalytics/webpack/runtime/make namespace object","webpack://kibanalytics/./src/client/tracker.client.js"],"sourcesContent":["import { getPrefixedAttributes } from './utils.client';\n\nexport default (element, className, prefix, type, value, trackEventFn) => () => {\n    const classData = {\n        name: className,\n        prefix,\n        type,\n        value\n    };\n\n    const elementData = {\n        tagName: element.tagName\n    };\n\n    const customData = getPrefixedAttributes('data-kbs-', element);\n\n    const data = {\n        class: classData,\n        element: elementData,\n        ...customData\n    };\n\n    const options = {\n        sendBeacon: data.element.tagName === 'A'\n    };\n    return trackEventFn(type, data, options);\n}","const hook = (_this, method, callback) => {\n    const orig = _this[method];\n\n    return (...args) => {\n        callback.apply(null, args);\n\n        return orig.apply(_this, args);\n    };\n};\n\nconst doNotTrack = () => {\n    const { doNotTrack, navigator, external } = window;\n\n    const msTrackProtection = 'msTrackingProtectionEnabled';\n    const msTracking = () => {\n        return external && msTrackProtection in external && external[msTrackProtection]();\n    };\n\n    const dnt = doNotTrack || navigator.doNotTrack || navigator.msDoNotTrack || msTracking();\n\n    return dnt == '1' || dnt === 'yes';\n};\n\nconst adBlockEnabled = () => {\n    let ade;\n    const boe = document.getElementsByTagName('body')[0];\n\n    if (boe) {\n        ade = document.createElement('div');\n        ade.setAttribute('class', 'ads ad adsbox doubleclick ad-placement carbon-ads');\n        ade.setAttribute('style', 'height:1px;width:1px;position: absolute;left:-999px;top:-999px;');\n        ade.textContent = '&nbsp;';\n        boe.appendChild(ade);\n    }\n\n    return !!ade && ade.offsetHeight === 0;\n}\n\nconst cookiesEnabled = (navigator && navigator.cookieEnabled) || !!document.cookie;\n\nconst getPrefixedAttributes = (attrPrefix, element) => {\n    return element\n        .getAttributeNames()\n        .reduce((acc, name) => {\n            if (name.startsWith(attrPrefix)) {\n                const attrName = name.replace(attrPrefix, '');\n                if (attrName) return { ...acc, [attrName]: element.getAttribute(name) }\n            }\n            return acc;\n        }, {});\n}\n\nexport {\n    hook,\n    doNotTrack,\n    adBlockEnabled,\n    cookiesEnabled,\n    getPrefixedAttributes\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import classListener from './class-listener.client';\nimport { adBlockEnabled, cookiesEnabled, doNotTrack, hook, getPrefixedAttributes } from './utils.client.js';\n\n(window => {\n    const {\n        screen,\n        navigator: { language, platform },\n        location: { hostname, pathname, search },\n        document,\n        history,\n    } = window;\n\n    const script = document.querySelector('script');\n    if (!script) return;\n\n    const attr = script.getAttribute.bind(script);\n\n    const tracker_id = attr('data-tracker-id');\n    if (!tracker_id) throw new Error('data-tracker-id not found');\n\n    const serverUrl = attr('data-server-url');\n    if (!serverUrl) throw new Error('data-server-url not found');\n\n    const metrics = getPrefixedAttributes('data-metrics-', script);\n\n    const eventClass = /^kbs-([a-z]+)-([\\w]+[\\w-]*)$/;\n    const eventSelector = '[class*=\\'kbs-\\']';\n    const listeners = {};\n    let currentUrl = `${pathname}${search}`;\n    let currentRef = document.referrer;\n\n    /* Collect metrics */\n\n    const getDefaultPayload = () => ({\n        tracker_id,\n        hostname,\n        url: currentUrl\n    });\n\n    const getPageViewPayload = () => ({\n        ...getDefaultPayload(),\n        referrer: currentRef,\n        platform,\n        screen: `${screen.width}x${screen.height}`,\n        language,\n        adBlock: adBlockEnabled(),\n        cookies: cookiesEnabled\n    });\n\n    const collect = (type, payload, sendBeacon = false) => {\n        if (doNotTrack()) return;\n\n        const url = `${serverUrl}/collect`;\n        const body = {\n            type,\n            metrics,\n            payload\n        }\n\n        if (sendBeacon) {\n            /*\n                A problem with sending analytics is that a site often wants to send analytics when the user\n                has finished with a page: for example, when the user navigates to another page. In this situation\n                the browser may be about to unload the page, and in that case the browser may choose not to send\n                asynchronous XMLHttpRequest requests.\n             */\n\n            const blob = new Blob([JSON.stringify(body)], { type : 'application/json' });\n            return navigator.sendBeacon(url, blob);\n        }\n\n        return fetch(url, {\n            method: 'post',\n            headers: {\n                'content-type': 'application/json'\n            },\n            body: JSON.stringify(body),\n            credentials: 'include'\n        });\n    };\n\n    const trackEvent = (type = 'custom', data = {}, options = {}) => {\n        const payload = (type === 'page-view')\n            ? getPageViewPayload()\n            : { ...getDefaultPayload(), data };\n\n        collect(type, payload, options.sendBeacon);\n    };\n\n    /* Handle events */\n\n    const addEvents = node => {\n        const elements = node.querySelectorAll(eventSelector);\n        Array.prototype.forEach.call(elements, addEvent);\n    };\n\n    const addEvent = element => {\n        const classes = element.getAttribute('class')?.split(' ');\n        for (const className of classes) {\n            if (!eventClass.test(className)) continue;\n\n            const [prefix, type, value] = className.split('-');\n            listeners[className] = listeners[className] || classListener(element, className, prefix, type, value, trackEvent);\n\n            element.addEventListener(type, listeners[className], true);\n        }\n    };\n\n    /* Handle history changes */\n\n    const handlePush = (state, title, url) => {\n        if (!url) return;\n\n        currentRef = currentUrl;\n        const newUrl = url.toString();\n\n        if (newUrl.substring(0, 4) === 'http') {\n            currentUrl = '/' + newUrl.split('/').splice(3).join('/');\n        } else {\n            currentUrl = newUrl;\n        }\n\n        if (currentUrl !== currentRef) {\n            trackEvent('page-view');\n        }\n    };\n\n    const observeDocument = () => {\n        const monitorMutate = mutations => {\n            mutations.forEach(mutation => {\n                const element = mutation.target;\n                addEvent(element);\n                addEvents(element);\n            });\n        };\n\n        const observer = new MutationObserver(monitorMutate);\n        observer.observe(document, { childList: true, subtree: true });\n    };\n\n    /* Global */\n\n    if (!window.kbs) {\n        window.kbs = {\n            trackEvent\n        };\n    }\n\n    /* Start */\n\n    if (!doNotTrack()) {\n        history.pushState = hook(history, 'pushState', handlePush);\n        history.replaceState = hook(history, 'replaceState', handlePush);\n\n        const update = () => {\n            if (document.readyState === 'complete') {\n                trackEvent('page-view');\n                addEvents(document);\n                observeDocument();\n            }\n        };\n\n        document.addEventListener('readystatechange', update, true);\n        update();\n    }\n})(window);"],"names":[],"sourceRoot":""}